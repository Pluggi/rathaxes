/*
  UNIT TEST OF THE PATCH LIB
*/

#include "cnormPatchLib.inc.cws"
#include "../cnorm2c/cnorm2c.inc.cws"

local newCode;
cnormPatchInit(newCode);

local stree;
cnormPatchInit(stree);

traceLine("FIRST INSERTION:");
cnormPatchDeclaration(stree, "typedef int prout;typedef int block;", newCode);
traceLine(cnorm2c(stree.block));

traceLine("ADDITIONNAL CODE WITH CUSTOM TYPE:");
cnormPatchDeclaration(stree, "block niania; prout gluglu;", newCode);
//traceLine(cnorm2c(stree.block));

traceLine("ADD EMPTY FUNCTION:");
cnormPatchDeclaration(stree, "int	main(char **av){}", newCode);
//traceLine(cnorm2c(stree.block));

traceLine("ADD FUNCTION PROTOTYPE:");
cnormPatchDeclaration(stree, "prout	foo(block);", newCode);
//traceLine(cnorm2c(stree.block));

traceLine("PATCH THE MAIN FUNCTION WITH DECLARATION AND STATEMENT:");
local main_code;
cnormPatchGetFunctionNode(stree, "main", main_code);
cnormPatchDeclaration(main_code, "int a = 42;");
cnormPatchDeclaration(main_code, "extern prout foo(block);", stree);
cnormPatchStatement(main_code, "if (foo(666)) printf(\"%d\\n\", a);");
//traceLine(cnorm2c(stree.block));

traceLine("ADD STRUCT AND UNION:");
cnormPatchDeclaration(stree, "struct test {int onefield;};");
cnormPatchDeclaration(stree, "union color_beneton {double anotherfield;};");
cnormPatchDeclaration(stree, "struct gloupier {};");
//traceLine(cnorm2c(stree.block));

traceLine("PATCH STRUCT AND UNION:");
local fields;
cnormPatchGetStructList(stree, "test", fields);
cnormPatchStructOrUnionFieldBack(fields, "prout blu;", stree);
cnormPatchStructOrUnionFieldFront(fields, "double gla;");
cnormPatchStructOrUnionFieldFront(fields, "struct object parent;");
cnormPatchGetUnionList(stree, "color_beneton", fields);
cnormPatchStructOrUnionFieldBack(fields, "prout toto;", stree);
cnormPatchStructOrUnionFieldFront(fields, "double jiji;");
cnormPatchStructOrUnionFieldBack(fields, "unsigned int unused;", stree);
cnormPatchStructOrUnionFieldFront(fields, "long;");
cnormPatchGetStructList(stree, "gloupier", fields);
cnormPatchStructOrUnionFieldBack(fields, "char *str;");
cnormPatchStructOrUnionFieldBack(fields, "unsigned long size;");
//traceLine(cnorm2c(stree.block));


traceLine("ADD ENUMS:");
cnormPatchDeclaration(stree, "enum glu {A=1};");
cnormPatchDeclaration(stree, "enum grots {};");
//traceLine(cnorm2c(stree.block));

traceLine("PATCH ENUMS:");
cnormPatchGetEnumList(stree, "glu", fields);
cnormPatchEnumFieldBack(fields, "B = 32");
cnormPatchEnumFieldBack(fields, "C = 55");
cnormPatchEnumFieldFront(fields, "NULL = 0");
cnormPatchEnumFieldFront(fields, "X = -1");
cnormPatchGetEnumList(stree, "grots", fields);
cnormPatchEnumFieldBack(fields, "B = 32");
cnormPatchEnumFieldBack(fields, "C = 55");
cnormPatchEnumFieldFront(fields, "NULL = 0");
cnormPatchEnumFieldFront(fields, "X = -1");
//traceLine(cnorm2c(stree.block));

traceLine("PATCH FUNCTION DEFINITION:");
local params;
cnormPatchGetFunctionParamList(stree, "main", params);
cnormPatchFunctionParamBack(params, "char **env");
cnormPatchFunctionParamFront(params, "int ac");
//traceLine(cnorm2c(stree.block));

traceLine("PATCH PROTOTYPE DEFINITION:");
local params;
cnormPatchGetProtoParamList(stree, "foo", params);
cnormPatchFunctionParamBack(params, "char []");
cnormPatchFunctionParamFront(params, "int ac, double c");
//traceLine(cnorm2c(stree.block));

traceLine("ADD FUNCTION:");
cnormPatchDeclaration(stree, "void test() {}", newCode);
//traceLine(cnorm2c(stree.block));

traceLine("PATCH THE TEST FUNCTION WITH A LABEL STATEMENT:");
local test_code;
cnormPatchGetFunctionNode(stree, "test", test_code);
cnormPatchDeclaration(test_code, "int a;");
cnormPatchStatement(test_code, "while_label: while(32) {}");

local while_code;
cnormPatchGetWhileNodeByLabel(test_code, "while_label", while_code);
cnormPatchDeclaration(while_code, "int a;");
cnormPatchStatement(while_code, "a = 42;");
cnormPatchStatement(test_code, "a += 2;");
cnormPatchStatement(test_code, "if_label: if(32) {} else {struct {int;double;} a;}");
cnormPatchStatement(test_code, "do_label: do {} while(42);");
cnormPatchStatement(test_code, "switch_label: switch(y) {case 0: z=666;case 42:toto=\"glovio\";break;}");
cnormPatchStatement(test_code, "for_label: for(int a; a < 42; ++a) {}");


local ifthen_code;
cnormPatchGetIfThenNodeByLabel(test_code, "if_label", ifthen_code);

cnormPatchDeclaration(ifthen_code, "int b;");
cnormPatchStatement(ifthen_code, "b = 42;");

local ifelse_code;
cnormPatchGetIfElseNodeByLabel(test_code, "if_label", ifelse_code);
cnormPatchDeclaration(ifelse_code, "int c;");
cnormPatchStatement(ifelse_code, "c = 42;");

local do_code;
cnormPatchGetDoWhileNodeByLabel(test_code, "do_label", do_code);
cnormPatchDeclaration(do_code, "int d;");
cnormPatchStatement(do_code, "d = 42;");

local forcode;
cnormPatchGetForNodeByLabel(test_code, "for_label", forcode);
cnormPatchDeclaration(forcode, "int e;");
cnormPatchStatement(forcode, "e = 42;");

local switch_code;
cnormPatchGetSwitchNodeByLabel(test_code, "switch_label", switch_code);
cnormPatchStatement(switch_code, "case 666: f = 42;");


traceLine(cnorm2c(stree.block));


saveProject("testPatchLib.xml", stree);
traceLine("GENERE LE C:");
traceLine(cnorm2c(newCode.block));

