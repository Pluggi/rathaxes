/*
**	registers.cws in scripts/semantics
**	for Rathaxes project
**	made by Thor
*/


declare function checkRegistersSemantics(theRegisters : node);
declare function checkRegisterDefinition(theDefinition : node);
declare function checkRegisterShape(theRegister : node);
declare function extractBeginFromRange(range : value);
declare function extractEndFromRange(range : value);
declare function valueInRange(range : value, val : value);
declare function checkRegisterVariablesSizes(theRegister : node);


/*
** This function iterates each register node in the
** AST and calls several sub-functions to check
** properties.
*/
function checkRegistersSemantics(theRegisters : node)
{
  foreach register in theRegisters
    {
      checkRegisterDefinition(register.definition);
      checkRegisterShape(register);
      checkRegisterVariablesSizes(register);
    }
  return;
}


/*
** This function checks if register's shape and length
** are the same.
*/
function checkRegisterDefinition(theDefinition : node)
{
  if (lengthString(theDefinition.shape) < theDefinition.size)
    rtxError("Shape for register '" + theDefinition.name + "' is shorter than declared: " + lengthString(theDefinition.shape) + '/' + theDefinition.size);
  if (lengthString(theDefinition.shape) > theDefinition.size)
    rtxError("Shape for register '" + theDefinition.name + "' is longer than declared: " + lengthString(theDefinition.shape) + '/' + theDefinition.size);
  return;
}


/*
** This function checks if the declared register's
** shape is matching the registers variables defined.
*/
function checkRegisterShape(theRegister : node)
{
  local idx = $theRegister.definition.size - 1$;
  local c;
  local shape = revStr(theRegister.definition.shape);
  local ok;

  while (idx >= 0)
    {
      ok = false;
      c = charAt(shape, idx);
      switch (c)
	{
	case '0':
	case '1': break;
	case '*':
	  foreach block in theRegister.block
	    {
	      if (valueInRange(block.definition.range, idx) == true)
		{ rtxError("Considering register '" + theRegister.definition.name + "''s shape (" + theRegister.definition.shape + "), bit [" + idx + "] can't be a register variable."); }
	    }
	  break;
	case '.':
	  foreach block in reverse theRegister.block
	    {
	      if (valueInRange(block.definition.range, idx) == true)
		{ ok = true; }
	    }
	  if (ok == false)
	    { rtxError("Considering register '" + theRegister.definition.name + "''s shape (" + theRegister.definition.shape + "), bit [" + idx + "] must be a register variable."); }
	  break;
	}
      idx = $idx - 1$;
    }
  return;
}


/*
** This function returns the begining
** of a range
*/
function extractBeginFromRange(range : value)
{
  local begin = "";
  local end = "";
  local idx = 0;
  local len = lengthString(range);
  
  while (idx < len)
    {
      if (!isNumeric(charAt(range, idx)))
	{ break; }
      else if (isNumeric(charAt(range, idx)))
	{ begin += charAt(range, idx); }
      idx = $idx + 1$;
    }
  return begin;
}


/*
** This function returns the end
** of a range or "" if range has
** one step.
*/
function extractEndFromRange(range : value)
{
  local end = "";
  local idx = 0;
  local len = lengthString(range);
  local bFlag = false;

  while (idx < len)
    {
      if (!isNumeric(charAt(range, idx)))
	{ bFlag = true; }
      else if (isNumeric(charAt(range, idx)) && bFlag = true)
	{ end += charAt(range, idx); }
      idx = $idx + 1$;
    }
  return end;
}


/*
** This function checks if a value
** is in a range
*/
function valueInRange(range : value, val : value)
{
  local begin = "";
  local end = "";
  local idx = 0;
  local len = lengthString(range);
  local bFlag = false;

  while (idx < len)
    {
      if (!isNumeric(charAt(range, idx)))
	{ bFlag = true; }
      else if (isNumeric(charAt(range, idx)) && bFlag = false)
	{ begin += charAt(range, idx); }
      else if (isNumeric(charAt(range, idx)) && bFlag = true)
	{ end += charAt(range, idx); }
      idx = $idx + 1$;
    }

  if (end == "" && begin == val)
    { return true; }

  if (begin <= val && val <= end)
    { return true; }

  return false;
}


/*
** This function checks if register variables
** size match the range length.
*/
function checkRegisterVariablesSizes(theRegister : node)
{
  local len;
  local begin;
  local end;

  foreach var in theRegister.block
    {
      begin = extractBeginFromRange(var.definition.range);
      end = extractEndFromRange(var.definition.range);
      if (end == "")
	{ end = begin; }
      foreach statement in var.block
	{
	  len = lengthString(statement.key());
	  if (len != $end - begin + 1$)
	    { rtxError("Variable state [" + theRegister.definition.name + "." + var.definition.name + '.' + statement + "] must have " + $end - begin + 1$ + " digits."); }
	}
    }
}
