/*
** "C normalise"
** Version 2.0
** 
** Authors:
**	Lionel Auroux
** Contributors:
**	Cedric Lemaire
**	David Giron
**	David Amsallem	
**
** Features:
** - Standard C 89 syntax
** - GnuC asm expression
** - GnuC __thread storage class specifier
** - GnuC parameter forward declaration
** - GnuC __extension__ evite les warnings sur l'utilisation d'extention GnuC
** - GnuC subscript
** - GnuC designated initializer
** - GnuC __builtin_offsetof
** - GnuC __builtin_va_list
** - c99 static in direct absolute declarator
** - c99 block as single expression ({ })
** - c99 typeof
** - c99 designation
** - c99 __alignof
** - c99 complex,__real & __imag operator
** - c99 range expression
** - c99 attributes
**
** This grammar was adapted from the one in section A13 of 
** The C programming language, second edition, 
** by Brian W. Kernighan and Dennis M. Ritchie 
** (Englewood Cliffs, New Jersey: Prentice Hall PTR, 1988; ISBN
** 0-13-110362-8), 
** pages 234 - 238. 
** 
** This file is based on the original document:
** http://www.cs.grinnell.edu/~stone/courses/languages/C-syntax.xhtml
** 
** A lot of change was done after reading:
** - ISO/IEC 9899:TC2
** - ISO/IEC 9899:1999
**
** V2.0 improvements are a totaly normalized AST and
** the corresponding generation templates.
*/


#include "cnormToolkit.inc.cws"
#include "cnormCreateDeclarationNode.inc.cws"

/*
  normalise les types int pour que le type soit toujours complet:
  ex: int devient signed int
  long long devient signed long long int
*/
function normalizeCType(theType : node)
{
  if (!existVariable(theType.identifier) 
      || theType.identifier == "__UNDEF__")
    insert theType.identifier = "int";
  if (theType#parent.type == "__UNDEF__")
    insert theType#parent.type = "__PRIMARY__";
  if ((theType.identifier == "int" || theType.identifier == "char")
      && !existVariable(theType.sign)
      )
    insert theType.sign = "signed";    
}

/*
  le specificateur de type contient essentiellement le type reel du symbole 
  declarer.
*/
function searchInTypes(key : value, type : node)
{	
	local leaf;
	if (existVariable(type#parent.pctx))
	  {
	    ref leaf = type#parent.pctx;
	    while (leaf.type == "{}"
		   || leaf.type == "switch"
		   || leaf.type == "while"
		   || leaf.type == "do"
		   || leaf.type == "if"
		   || leaf.type == "for"
		   || leaf.type == "return" // ({}) peut declarer des types
		   )
	      {
		// au niveau local
		if (findElement(key, leaf.types))
		  { return true; }
		// on remonte d'un cran
		ref leaf = leaf#parent;
	      }
	  }
	// au niveau global
	if (findElement(key, this.block.types))
	  { return true; }	
	return false;
}

//----------------------------------------------------------------------------
//                           B E G I N - C - N O R M
//----------------------------------------------------------------------------

/*
  Racine de la grammaire
*/
translation_unit(c_tree : node) ::=
#ignore
[	
 declaration(c_tree.block) 
 | /* GnuC asm expression */ asm_expr
]*
;

/*
  GNU C bloc assembleur de haut niveau
*/
asm_expr ::= 
#readIdentifier:{"asm","__asm","__asm__"} [#readIdentifier:{"volatile"}]? 
   '(' 
	=> local subExp;
	/* le plus souvent expression contient des expressions asm */
	expression(subExp)  
   ')' ';'
;

// la suite de la grammaire decoupe en 3 fichier pour plus de lisibilite
#include "cnormDeclarations.cwp"
#include "cnormExpressions.cwp"
#include "cnormStatements.cwp"


//----------------------------------------------------------------------------
//                              E N D - C - N O R M
//----------------------------------------------------------------------------
