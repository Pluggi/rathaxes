/*
** cnormStatements.cwp for
** "C normalise"
** Version 2.0
** 
** Authors:
**	Lionel Auroux
** Contributors:
**	Cedric Lemaire
**	David Giron
**	David Amsallem	
**
** Features:
** - Standard C 89 syntax
** - GnuC asm expression
** - GnuC __thread storage class specifier
** - GnuC parameter forward declaration
** - GnuC __extension__ evite les warnings sur l'utilisation d'extention GnuC
** - GnuC subscript
** - GnuC designated initializer
** - GnuC __builtin_offsetof
** - GnuC __builtin_va_list
** - c99 static in direct absolute declarator
** - c99 block as single expression ({ })
** - c99 typeof
** - c99 designation
** - c99 __alignof
** - c99 complex,__real & __imag operator
** - c99 range expression
** - c99 attributes
**
** This grammar was adapted from the one in section A13 of 
** The C programming language, second edition, 
** by Brian W. Kernighan and Dennis M. Ritchie 
** (Englewood Cliffs, New Jersey: Prentice Hall PTR, 1988; ISBN
** 0-13-110362-8), 
** pages 234 - 238. 
** 
** This file is based on the original document:
** http://www.cs.grinnell.edu/~stone/courses/languages/C-syntax.xhtml
** 
** A lot of change was done after reading:
** - ISO/IEC 9899:TC2
** - ISO/IEC 9899:1999
**
** V2.0 improvements are a totaly normalized AST, corrections through the BNF
** and the corresponding generation templates.
*/

//----------------------------------------------------------------------------
//                              S T A T E M E N T S
//----------------------------------------------------------------------------

/*
  Cette partie est la plus simple de la grammaire est decrit comment on
  ecrit des phrases en C.
*/
single_statement(theStatement : node) ::=
	["__extension__"]? /* GnuC : pour enlever les warnings des extensions */
	[
		compound_statement(theStatement)
		| labeled_statement(theStatement)
		| expression_statement(theStatement)
	]
;

/*
  block entre accolade
*/
compound_statement(theStatement : node) ::=
'{'  #continue
	[ block_item_list(theStatement) ]?
'}'
;

/*
  suite de phrase en C
*/
block_item_list(theStatement : node) ::=
	=> insert theStatement.type = "{}";
	[
		 // declaration variable
	 declaration(theStatement)
	 | // ou code 
	 single_statement(theStatement)
	]*
;

/*
  structure du langage (if,for,while) et label
*/
labeled_statement(theStatement : node) ::=
	#readIdentifier:sKeyword statement<sKeyword>(theStatement)
;

/*
  label
 */
statement<sKeyword>(theStatement : node) ::= ':' #continue
	=> pushItem theStatement;
	=> insert theStatement#back.type = "label";
	=> insert theStatement#back.label = sKeyword;
	[single_statement(theStatement#back.block)]?
;

/*
  if else
*/
statement<"if">(theStatement : node) ::= #continue
	=> pushItem theStatement;
	=> insert theStatement#back.type = "if";
	'(' expression(theStatement#back.condition) ')' 
	single_statement(theStatement#back.then)
	[ "else" #continue single_statement(theStatement#back.else) ]?
;

/*
  switch
*/
statement<"switch">(theStatement : node) ::=
	#continue
	=> pushItem theStatement;
	=> insert theStatement#back.type = "switch";
	'(' expression(theStatement#back.condition) ')' 
	single_statement(theStatement#back.switch)
;

/*
  case d'un switch
*/
statement<"case">(theStatement : node) ::= #continue
	=> pushItem theStatement;
	=> insert theStatement#back.type = "case";
	[
	 range_expression(theStatement#back.case)	/* GnuC */
	 | constant_expression(theStatement#back.case) 
	]
	':'
	[single_statement(theStatement#back.block)]?
;

/*
  default d'un switch
*/
statement<"default">(theStatement : node) ::= #continue
	=> pushItem theStatement;
	=> insert theStatement#back.type = "default";
	':'
	[single_statement(theStatement#back.block)]?
;


/*
  while
*/
statement<"while">(theStatement : node) ::= #continue
	=> pushItem theStatement;
	=> insert theStatement#back.type = "while";
	'(' expression(theStatement#back.condition) ')' 
	single_statement(theStatement#back.block)
;

/*
  do while
*/
statement<"do">(theStatement : node) ::= #continue
	=> pushItem theStatement;
	=> insert theStatement#back.type = "do";
	single_statement(theStatement#back.block) "while" 
	'(' expression(theStatement#back.condition) ')' ';'
;

/*
  for
*/
statement<"for">(theStatement : node) ::= #continue
	=> pushItem theStatement;
	=> insert theStatement#back.type = "for";
	'(' 
	 [ expression(theStatement#back.init)	]? ';' 
	 [ expression(theStatement#back.condition) ]? ';' 
	 [ expression(theStatement#back.increment) ]? 
	 ')' 
	single_statement(theStatement#back.block)
;

/* goto */
statement<"goto">(theStatement : node) ::=
	#continue
	=> pushItem theStatement;
	=> insert theStatement#back.type = "goto";
	constant_expression(theStatement#back.expr):theStatement#back.label /* maybe I should send a fake node */
	';'
;

/* continue */
statement<"continue">(theStatement : node) ::=
	#continue 
	=> pushItem theStatement;
	=> insert theStatement#back.type = "continue"; 
	';'
;

/* break */
statement<"break">(theStatement : node) ::=
	#continue 
	=> pushItem theStatement;
	=> insert theStatement#back.type = "break"; 
	';'
;

/* return */
statement<"return">(theStatement : node) ::=
	#continue
=> traceLine("return");
	=> pushItem theStatement;
	=> insert theStatement#back.type = "return";
	[
	 #pushItem(theStatement#back.block)
	 expression(theStatement#back.block)
	 ]?:sK
=> traceLine("return:" + sK);	
	#continue ';'	
;

/* expression en C finit par un ; */
expression_statement(theStatement : node) ::=
	[ #pushItem(theStatement)
	  expression(theStatement#back)
	]? ';'
;


/* Ici la liste des identifiants */
identifier ::= #readIdentifier:sId 
	#check(!(sId in 
	    {"auto", "register", "static", "extern", "inline", "typedef", 
	     "void", "char", "short", "int", "long", "float", "double", 
	     "signed", "unsigned", "struct", "union", "const",
	     "volatile", "sizeof", "enum", "case", "default", 
	     "if", "else", "while", "do", "for", "goto", "continue", 
	     "break", "return", "asm",
	     /* c99 & GnuC */
	     "typeof", "__typeof", "__typeof__",
	     "__complex", "__complex__", "_Complex",
	     "__alignof", "__alignof__", "_Bool",
	     "__label__", "attribute", "__attribute", "__attribute__",
	     "__real", "__imag", "__real__", "__imag__",
	     "_Imaginary", "__asm", "__asm__", 
	     "__builtin_offsetof", "__builtin_va_list",
	     "__extension__", "__const", "__restrict", "__inline"
	    }))
;
